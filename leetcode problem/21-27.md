## 21.js

```javascript
var mergeTwoLists = function(l1, l2) {
    let head = new ListNode(-1), tail = head;

    while(l1 && l2) {
        if(l1.val <l2.val) {
            tail = tail.next = l1;
            l1 = l1.next
        } else {
            tail = tail.next = l2;
            l2 = l2.next
        }
    }
    if(l1) tail.next = l1;
    if(l2) tail.next = l2;

    return head.next
};
```



## 22.js

```javascript
/**
 * @param {number} n
 * @return {string[]}
 */
var res = [];
var generateParenthesis = function (n) {
    res = []
    dfs(n, 0, 0, '')
    return res;
};

function dfs(n, lc, rc, seq) {
    if (lc === n && rc === n) {
        res.push(seq);
        return
    }
    if (lc < n) dfs(n, lc + 1, rc, seq + '(');
    if(lc > rc && rc < n) dfs(n, lc, rc + 1, seq + ')')



}
```



## 23.cpp

> 为了使用c++的优先队列 懒了

```c++
class Solution {
public:
    struct Status {
        int val;
        ListNode *ptr;
        // 重载 < 操作符
        bool operator < (const Status &rhs) const {
            return val > rhs.val;
        }
    };

    priority_queue <Status> q;

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        for (auto node: lists) {
            if (node) q.push({node->val, node});
        }
        ListNode head, *tail = &head;
        while (!q.empty()) {
            auto f = q.top(); q.pop();
            tail->next = f.ptr; 
            tail = tail->next;
            if (f.ptr->next) q.push({f.ptr->next->val, f.ptr->next});
        }
        return head.next;
    }
};
```



## 24.js

```javascript
var swapPairs = function(head) {
    var dummy = new ListNode(-1);
    dummy.next = head,
    p = dummy;

    while(p.next && p.next.next) {
        let a = p.next,
            b = p.next.next;
        p.next = b;
        a.next = b.next;
        b.next = a;

        p = a;
    }

    return dummy.next
};
```



## 25.js

```javascript
var reverseKGroup = function(head, k) {

    var dummy = new ListNode(-1);
    dummy.next = head;

    for(p = dummy;;) {
        let q = p;
        for(let i=0; i< k && q; i++) q = q.next;
        if(!q) break;

        let a = p.next, b = a.next;
        for(let i=0; i< k-1; i++) {
            let c = b.next;
            b.next = a;
            a = b, b=c;
        }
        let c = p.next;
        p.next = a,
        c.next = b;
        p = c;
    }

    return dummy.next;

};
```



## 26.js

```javascript
var removeDuplicates = function (nums) {
    let len = nums.length;
    if (len === 0 || len === 1) {
        return len;
    }
    let i = 0, j = 1;

    while (j < len) {
        if (nums[i] === nums[j]) j++;
        else if (nums[i] !== nums[j]) nums[++i] = nums[j++]
    }

    return i + 1;
};
```



## 27.js

```javascript
var removeElement = function (nums, val) {
    let k = 0;
    for (let i = 0; i < nums.length; i++) { 
        if(nums[i] !== val) {
            nums[k++] = nums[i]
        }
    }
    return k;
};
```

