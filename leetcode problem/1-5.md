### 01.cpp

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> heap;
        for(int i=0; i< nums.size(); i++) {
            int r = target - nums[i];
            if(heap.count(r)) {
                return {heap[r], i};
            }
            else {
                heap[nums[i]] = i;
            }
        }
        return {};
    }
};

```

### 02.cpp
```c++

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* head = new ListNode(-1);
        ListNode* cur = head;
        int t = 0;
        while(l1 || l2 || t) {
            if(l1) t+= l1->val,l1 = l1->next;
            if(l2) t+=l2->val, l2 = l2->next;
            cur = cur->next = new ListNode(t % 10);
            t = t / 10;
        }
        return head->next;
    }

};
```


### 03.cpp

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> heap;
        int res = 0;
        for(int i = 0, j = 0; i < s.size(); i++) {
            heap[s[i]] ++;
            
            while(heap[s[i]] > 1) heap[s[j++]] --;

            res = max(res, i - j + 1 );
        }
        return res;
    }
};

```


### 04.cpp

```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int total = nums1.size() + nums2.size();

        if(total % 2 == 0) {
            int left = find(nums1, 0, nums2, 0, total / 2);
            int right = find(nums1, 0, nums2, 0, total / 2 + 1);
            return (left + right) / 2.0;
        } else {
            return find(nums1, 0, nums2, 0, total / 2 + 1);
        }
    }

    int find(vector<int>& nums1, int i, vector<int >& nums2, int j, int k) {
        if(nums1.size() - i > nums2.size() - j) return find(nums2, j, nums1, i, k);

        if(k == 1) {
            if(nums1.size() == i) {
                return nums2[j];
            }
            else {
                return min(nums1[i], nums2[j]);
            }
        } 
        if(nums1.size() == i) return nums2[j + k - 1];

        int si = min((int)nums1.size(), i + k / 2), sj = j + k - k / 2 ;

        if(nums1[si - 1] > nums2[sj - 1]) 
            return find(nums1, i, nums2, sj, k - (sj - j));
        else 
            return find(nums1, si, nums2, j, k - (si - i));
    }
};


```




### 05.cpp

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        string res;
        for(int i = 0; i < s.size(); i++) {
            int l = i - 1, r = i + 1;
            while(l >=0 && r < s.size() && s[l] == s[r]) l--, r ++;

            if(res.size() < r - l - 1) res = s.substr(l + 1, r - l - 1);

            l = i , r = i + 1;
            while(l >=0 && r < s.size() && s[l] == s[r]) l--, r++;

            if(res.size() < r - l - 1) res = s.substr(l + 1, r - l - 1);
        }
        return res;
    }
};

```